

此博文不具体给出其算法的代码，只对其中算法进行分并且给予证明

PS：这些算法我不用证明都是它是正确的（上世纪的数学家看着这些都不用证明，为啥，很简单的），但是我坚持重新证明一遍实际是为了加深印象，并且理解其中的道理和思想，这样在以后的运用中才能灵活运用，当然证明这些算法也



**算法一：Floyd 算法，也是传说中的只用五行就可以解决的多源最短路径问题**

采用邻接矩阵来储存图，时间复杂度为O（n^3），能解决含正权，负权的最短路径，不能解决含有负**环**的最短路径（负环也没有最短路径）



```cpp
for(k=1;k<=n;k++)
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(e[i][j]>e[i][k]+e[k][j])
                 e[i][j]=e[i][k]+e[k][j];```








**当k=1时进行一个嵌套的for循环求出来的是任意两点之间只允许经过点1的最短路径，这个都可以理解吧。**

**(**￣▽￣)"

**当k=2时，经过一个if else的判断最终求出来的是任意两个顶点之间只允许经过1 2号顶点的最短路径。**

这时候可能有人说在进行 if      else 之后判断的是i->j通过2号顶点路径后路径能否缩小，那么如果i->j还能通过1号顶点再次缩小路径，那还能体现出来吗？

好的下面咱们来证明

假设咱们判断过之后i->j之间通过2号顶点可以缩小路径，此时i与j的路径为i->2->j，假设还可以通过1号顶点缩小路径（也就是上面所说的情况）

此时1号顶点肯定在i->j之间，也就是i->2或2->j之间 ，**而咱们在第一次for循环之后的意义上面已经说过了，即任意两点可以经过1号顶点后更新的最短路径**，那么回过来即i->2之间或者2->j之间若可以经过1号顶点在缩短路径，那么铁定在第一次循环后就已经在i->2或2->j之间添加1号顶点了，所以上面的担心是多余的(●'◡'●)

当k=2的循环结束后，得到的意义便是任意两个顶点只允许经过1 2号顶点的最短路径

</

